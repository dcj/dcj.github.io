{"version":3,"sources":["sci/impl/analyzer.cljc"],"mappings":"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","names":["sci.impl.analyzer/special-syms","sci.impl.analyzer/macros","p__106153","map__106154","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","allow","cljs.core.get","deny","sci.impl.analyzer/check-permission!","check-sym","sym","G__106156","G__106157","sci.impl.utils/kw-identical?","cljs.core/meta","sci.impl.utils/strip-core-ns","cljs.core/contains?","sci.impl.utils.throw_error_with_location","p__106160","map__106162","env","sci.impl.analyzer/lookup*","ctx","call?","cljs.core/deref","sym-ns","G__106167","cljs.core/namespace","cljs.core.symbol","sym-name","cljs.core/name","cnn","sci.impl.vars/current-ns-name","the-current-ns","G__106168","or__4126__auto__","cljs.core.get_in","cljs.core/find","and__4115__auto__","cljs.core._EQ_","G__106175","temp__5735__auto__","v","G__106177","clazz","sci.impl.interop/resolve-class","cljs.core/with-meta","G__106190","c","sci.impl.analyzer/tag","_ctx","expr","m","p__106205","map__106207","bindings","sci.impl.analyzer/lookup","vec__106212","cljs.core.nth","k","kv","vec__106218","t","sci.impl.utils/mark-resolve-sym","cljs.core.vary_meta","cljs.core/assoc","vec__106228","_","temp__5733__auto__","cljs.core/not","var_args","G__106246","sci.impl.analyzer/resolve-symbol","js/Error","sci.impl.analyzer.resolve_symbol","res","cljs.core/second","n","clojure.string/starts-with?","clojure.string/ends-with?","cljs.core.subs","sci.impl.analyzer/analyze-children","children","p1__106267#","cljs.core.mapv","sci.impl.analyzer/analyze","sci.impl.analyzer/maybe-destructured","params","body","cljs.core/every?","cljs.core/symbol?","new-params","lets","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/Symbol","cljs.core/first","cljs.core/next","cljs.core.conj","gparam","cljs.core.gensym","p__106310","p__106311","map__106312","fn-expr","vec__106313","seq__106314","first__106315","sci.impl.analyzer/expand-fn-args+body","fn-name","binding-vector","body-exprs","macro?","cljs.core/vector?","map__106327","cljs.core.into","fixed-args","p1__106290#","cljs.core.take_while","cljs.core.not_EQ_","fixed-arity","cljs.core/count","var-arg-name","p1__106291#","cljs.core.drop_while","next-body","conds","e","cljs.core/map?","pre","post","cljs.core/vec","cljs.core.map","cljs.core.update","cljs.core/merge","cljs.core/zipmap","cljs.core.repeat","p__106355","vec__106357","seq__106358","first__106359","sci.impl.analyzer/expand-fn","_fn","name?","cljs.core.assoc","cljs.core/cons","bodies","cljs.core/seq?","cljs.core/assoc-in","analyzed-bodies","cljs.core.reduce","p__106366","map__106368","max-fixed","min-varargs","acc","arglist","new-min-varargs","x__4214__auto__","y__4215__auto__","cljs.core/conj","arities","arglists","sci.impl.analyzer/expand-let*","destructured-let-bindings","exprs","vec__106396","new-let-bindings","p__106400","p__106401","vec__106404","vec__106407","binding-name","binding-value","cljs.core.partition","sci.impl.utils/mark-eval-call","p__106416","vec__106417","seq__106418","first__106419","sci.impl.analyzer/expand-let","_let","let-bindings","sci.impl.destructure/destructure","p__106425","vec__106427","seq__106428","first__106429","sci.impl.analyzer/expand->","x","forms","expanded","form","threaded","p__106439","vec__106440","seq__106441","first__106442","sci.impl.analyzer/expand-as->","_as","name","vec__106444","seq__106445","first__106446","cljs.core.interleave","cljs.core/butlast","cljs.core/empty?","cljs.core/last","sci.impl.analyzer/expand-def","vec__106458","_def","var-name","?docstring","?init","G__106463","G__106464","sci.impl.analyzer/expand-declare","cljs.core/simple-symbol?","arg-count","docstring","expected-arg-count","init","sci.impl.vars/current-ns","p__106486","vec__106487","seq__106489","first__106490","sci.impl.analyzer/expand-defn","op","G__106493","G__106494","vec__106496","pre-body","cljs.core/split-with","cljs.core.comp","cljs.core/sequential?","ds","meta-map","G__106509","G__106510","cljs.core.merge","fn-body","f","G__106514","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","sci.impl.analyzer/expand-comment","seq106515","G__106516","self__4723__auto__","_body","sci.impl.analyzer/expand-loop","vec__106534","bv","arg-names","cljs.core.take_nth","init-vals","cljs.core/rest","syms","cljs.core.repeatedly","bv1","cljs.core/vector","bv2","cljs.core/cat","cljs.core/nnext","expansion","cljs.core.list_STAR_","sci.impl.analyzer/expand-lazy-seq","G__106545","G__106546","p__106554","vec__106556","seq__106557","first__106558","sci.impl.analyzer/expand-if","_if","G__106559","sci.impl.analyzer/expand-case","G__106560","G__106561","clauses","match-clauses","result-clauses","default","cljs.core/odd?","G__106565","G__106566","cases","assoc-new","case-map","ret-map","vec__106574","seq__106575","first__106576","cljs.core/list?","ret","p__106585","vec__106586","seq__106587","first__106588","sci.impl.analyzer/expand-try","_try","vec__106589","catches","finally","catch-exprs","finally-expr","G__106601","G__106602","vec__106607","seq__106608","first__106609","ex","binding","G__106613","G__106614","G__106615","G__106616","p__106626","vec__106628","seq__106629","first__106630","_declare","names","_expr","cljs.core.swap_BANG_","cljs.core.update_in","current-ns","G__106642","sci.impl.vars/->SciVar","sci.impl.vars/current-file","p__106656","vec__106657","seq__106658","first__106659","sci.impl.analyzer/expand-dot","_dot","instance-expr","method-expr","args","vec__106661","seq__106662","first__106663","sci.impl.utils/vary-meta*","sci.impl.records.resolve_record_class","sci.impl.analyzer/expand-dot**","p__106680","vec__106682","seq__106683","first__106684","sci.impl.analyzer/expand-dot*","method-name","obj","p__106686","vec__106687","seq__106688","first__106689","sci.impl.analyzer/expand-new","_new","class-sym","map__106692","constructor","_opts","sci.impl.interop/resolve-class-opts","record","p__106707","vec__106710","seq__106711","first__106712","sci.impl.analyzer/expand-constructor","constructor-sym","constructor-name","p__106717","vec__106719","seq__106720","first__106721","sci.impl.analyzer/analyze-ns-form","_ns","ns-name","cljs.core.pr_str","vec__106730","vec__106733","fexpr","attr-map","sci.impl.utils/set-namespace!","vec__106762","seq__106763","first__106764","G__106765","cljs.core/Keyword","p__106769","vec__106770","sci.impl.analyzer/analyze-var","p__106777","vec__106778","sci.impl.analyzer/analyze-set!","sci.impl.types/getVal","sci.impl.analyzer/macro?","sci.impl.analyzer/analyze-call","special-sym","sci.impl.vars/var?","sci.impl.vars/isMacro","f-meta","eval?","G__106822","sci.impl.analyzer.expand_comment","sci.impl.for-macro/expand-for","G__106838","G__106839","sci.impl.doseq-macro/expand-doseq","e106858","needs-ctx?","G__106863","G__106864","sci.impl.utils/rethrow-with-location-of-node","sci.impl.utils/constant?","sci.impl.types/->EvalVar","sci.impl.utils/merge-meta","cljs.core/keys","cljs.core/vals","sci.impl.utils/mark-eval","cljs.core/set?","cljs.core/empty","cljs.core/select-keys"],"sourcesContent":["(ns sci.impl.analyzer\n  {:no-doc true}\n  (:refer-clojure :exclude [destructure macroexpand macroexpand-all macroexpand-1])\n  (:require\n   [clojure.string :as str]\n   [sci.impl.destructure :refer [destructure]]\n   [sci.impl.doseq-macro :refer [expand-doseq]]\n   [sci.impl.for-macro :refer [expand-for]]\n   [sci.impl.interop :as interop]\n   [sci.impl.records :as records]\n   [sci.impl.types :as types]\n   [sci.impl.utils :as utils :refer\n    [mark-resolve-sym mark-eval mark-eval-call constant?\n     rethrow-with-location-of-node throw-error-with-location\n     merge-meta kw-identical? strip-core-ns set-namespace!]]\n   [sci.impl.vars :as vars])\n  #?(:clj (:import [sci.impl Reflector])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; derived from (keys (. clojure.lang.Compiler specials))\n;; (& monitor-exit case* try reify* finally loop* do letfn* if clojure.core/import* new deftype* let* fn* recur set! . var quote catch throw monitor-enter def)\n(def special-syms '#{try finally do if new recur quote catch throw def . var set!})\n\n;; Built-in macros.\n\n(def macros '#{do if and or -> as-> quote quote* let fn fn* def defn\n               comment loop lazy-seq for doseq case try defmacro\n               declare expand-dot* expand-constructor new . import in-ns ns var\n               set! resolve macroexpand-1 macroexpand})\n\n(defn check-permission! [{:keys [:allow :deny]} check-sym sym]\n  (when-not (kw-identical? :allow (-> sym meta :line))\n    (let [check-sym (strip-core-ns check-sym)]\n      (when-not (if allow (contains? allow check-sym)\n                    true)\n        (throw-error-with-location (str sym \" is not allowed!\") sym))\n      (when (if deny (contains? deny check-sym)\n                false)\n        (throw-error-with-location (str sym \" is not allowed!\") sym)))))\n\n(defn lookup* [{:keys [:env] :as ctx} sym call?]\n  (let [sym-ns (some-> (namespace sym) symbol)\n        sym-name (symbol (name sym))\n        env @env\n        cnn (vars/current-ns-name)\n        the-current-ns (-> env :namespaces cnn)\n        ;; resolve alias\n        sym-ns (when sym-ns (or (get-in the-current-ns [:aliases sym-ns])\n                                sym-ns))]\n    (or (find the-current-ns sym) ;; env can contain foo/bar symbols from bindings\n        (cond\n          (and sym-ns (or (= sym-ns 'clojure.core) (= sym-ns 'cljs.core)))\n          (or (some-> env :namespaces (get 'clojure.core) (find sym-name))\n              (when-let [v (when call? (get macros sym-name))]\n                [sym v]))\n          sym-ns\n          (or (some-> env :namespaces sym-ns (find sym-name))\n              (when-let [clazz (interop/resolve-class ctx sym-ns)]\n                [sym (with-meta\n                       [clazz sym-name]\n                       #?(:clj\n                          (if call?\n                            {::static-access true}\n                            {:sci.impl/op :static-access})\n                          :cljs {:sci.impl/op :static-access}))]))\n          :else\n          ;; no sym-ns, this could be a symbol from clojure.core\n          (when-not (contains?\n                     (get-in the-current-ns [:refer 'clojure.core :exclude]) sym-name)\n            (or\n             (some-> env :namespaces (get 'clojure.core) (find sym-name))\n             (when (when call? (get macros sym))\n               [sym sym])\n             (when-let [c (interop/resolve-class ctx sym)]\n               [sym c])))))))\n\n(defn tag [_ctx expr]\n  (when-let [m (meta expr)]\n    (:tag m)))\n\n(defn lookup [{:keys [:bindings] :as ctx} sym call?]\n  (let [[k v :as kv]\n        (or\n         ;; bindings are not checked for permissions\n         (when-let [[k v]\n                    (find bindings sym)]\n           ;; never inline a binding at macro time!\n           (let [t (tag ctx v)\n                 v (mark-resolve-sym k)\n                 ;; pass along tag of expression!\n                 v (if t (vary-meta v\n                                    assoc :tag t)\n                       v)]\n             [k v]))\n         (when-let\n             [[k _ :as kv]\n              (or\n               (lookup* ctx sym call?)\n               #_(when (= 'recur sym)\n                   [sym sym]))]\n           (check-permission! ctx k sym)\n           kv))]\n    ;; (prn 'lookup sym '-> res)\n    (if-let [m (and (not (:sci.impl/prevent-deref ctx))\n                    (meta k))]\n      (if (:sci.impl/deref! m)\n        ;; the evaluation of this expression has been delayed by\n        ;; the caller and now is the time to deref it\n        [k (with-meta [v]\n             {:sci.impl/op :deref!})]\n        kv)\n      kv)))\n\n(defn resolve-symbol\n  ([ctx sym] (resolve-symbol ctx sym false))\n  ([ctx sym call?]\n   (let [sym sym ;; (strip-core-ns sym)\n         res (second\n              (or\n               (lookup ctx sym call?)\n               ;; TODO: check if symbol is in macros and then emit an error: cannot take\n               ;; the value of a macro\n               (let [n (name sym)]\n                 (cond\n                   (and call?\n                        (str/starts-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-dot*] ;; method invocation\n                   (and call?\n                        (str/ends-with? n \".\")\n                        (> (count n) 1))\n                   [sym 'expand-constructor]\n                   (str/starts-with? n \"'\") ;; TODO: deprecated?\n                   (let [v (symbol (subs n 1))]\n                     [v v])\n                   :else (throw-error-with-location\n                          (str \"Could not resolve symbol: \" (str sym))\n                          sym)))))]\n     ;; (prn 'resolve sym '-> res (meta res))\n     res)))\n\n(declare analyze analyze-call)\n\n(defn analyze-children [ctx children]\n  (mapv #(analyze ctx %) children))\n\n(defn maybe-destructured\n  [params body]\n  (if (every? symbol? params)\n    {:params params\n     :body body}\n    (loop [params params\n           new-params (with-meta [] (meta params))\n           lets []]\n      (if params\n        (if (symbol? (first params))\n          (recur (next params) (conj new-params (first params)) lets)\n          (let [gparam (gensym \"p__\")]\n            (recur (next params) (conj new-params gparam)\n                   (-> lets (conj (first params)) (conj gparam)))))\n        {:params new-params\n         :body [`(let ~lets\n                   ~@body)]}))))\n\n(defn expand-fn-args+body [{:keys [:fn-expr] :as ctx} fn-name [binding-vector & body-exprs] macro?]\n  (when-not binding-vector\n    (throw-error-with-location \"Parameter declaration missing.\" fn-expr))\n  (when-not (vector? binding-vector)\n    (throw-error-with-location \"Parameter declaration should be a vector\" fn-expr))\n  (let [binding-vector (if macro? (into ['&form '&env] binding-vector)\n                           binding-vector)\n        fixed-args (take-while #(not= '& %) binding-vector)\n        fixed-arity (count fixed-args)\n        var-arg-name (second (drop-while #(not= '& %) binding-vector))\n        next-body (next body-exprs)\n        conds (when next-body\n                (let [e (first body-exprs)]\n                  (when (map? e) e)))\n        body-exprs (if conds next-body body-exprs)\n        conds (or conds (meta binding-vector))\n        pre (:pre conds)\n        post (:post conds)\n        body-exprs (if post\n                     `((let [~'% ~(if (< 1 (count body-exprs))\n                                    `(do ~@body-exprs)\n                                    (first body-exprs))]\n                         ~@(map (fn* [c] `(assert ~c)) post)\n                         ~'%))\n                     body-exprs)\n        body-exprs (if pre\n                     (concat (map (fn* [c] `(assert ~c)) pre)\n                             body-exprs)\n                     body-exprs)\n        {:keys [:params :body]} (maybe-destructured binding-vector body-exprs)\n        ctx (update ctx :bindings merge (zipmap params\n                                                (repeat nil)))\n        body (analyze-children ctx body)]\n    #:sci.impl{:body body\n               :params params\n               :fixed-arity fixed-arity\n               :var-arg-name var-arg-name\n               :fn-name fn-name}))\n\n(defn expand-fn [ctx [_fn name? & body :as fn-expr] macro?]\n  (let [ctx (assoc ctx :fn-expr fn-expr)\n        fn-name (if (symbol? name?)\n                  name?\n                  nil)\n        body (if fn-name\n               body\n               (cons name? body))\n        ;; fn-name (or fn-name (gensym* \"fn\"))\n        bodies (if (seq? (first body))\n                 body\n                 [body])\n        ctx (if fn-name (assoc-in ctx [:bindings fn-name] nil)\n                ctx)\n        analyzed-bodies (reduce\n                         (fn [{:keys [:max-fixed :min-varargs] :as acc} body]\n                           (let [arglist (first body)\n                                 body (expand-fn-args+body ctx fn-name body macro?)\n                                 body (assoc body :sci.impl/arglist arglist)\n                                 var-arg-name (:sci.impl/var-arg-name body)\n                                 fixed-arity (:sci.impl/fixed-arity body)\n                                 new-min-varargs (when var-arg-name fixed-arity)]\n                             (when (and var-arg-name min-varargs)\n                               (throw-error-with-location \"Can't have more than 1 variadic overload\" fn-expr))\n                             (when (and (not var-arg-name) min-varargs (> fixed-arity min-varargs))\n                               (throw-error-with-location\n                                \"Can't have fixed arity function with more params than variadic function\" fn-expr))\n                             (-> acc\n                                 (assoc :min-varargs new-min-varargs\n                                        :max-fixed (max (:sci.impl/fixed-arity body)\n                                                        max-fixed))\n                                 (update :bodies conj body)\n                                 (update :arglists conj arglist))))\n                         {:bodies []\n                          :arglists []\n                          :min-var-args nil\n                          :max-fixed -1} bodies)\n        arities (:bodies analyzed-bodies)\n        arglists (:arglists analyzed-bodies)]\n    (with-meta #:sci.impl{:fn-bodies arities\n                          :fn-name fn-name\n                          :arglists arglists\n                          :fn true}\n      {:sci.impl/op :fn})))\n\n(defn expand-let*\n  [ctx destructured-let-bindings exprs]\n  (let [[ctx new-let-bindings]\n        (reduce\n         (fn [[ctx new-let-bindings] [binding-name binding-value]]\n           (let [v (analyze ctx binding-value)]\n             [(update ctx :bindings assoc binding-name v)\n              (conj new-let-bindings binding-name v)]))\n         [ctx []]\n         (partition 2 destructured-let-bindings))]\n    (mark-eval-call `(~'let ~new-let-bindings ~@(analyze-children ctx exprs)))))\n\n(defn expand-let\n  \"The let macro from clojure.core\"\n  [ctx [_let let-bindings  & exprs]]\n  (let [let-bindings (destructure let-bindings)]\n    (expand-let* ctx let-bindings exprs)))\n\n(defn expand->\n  \"The -> macro from clojure.core.\"\n  [ctx [x & forms]]\n  (let [expanded\n        (loop [x x, forms forms]\n          (if forms\n            (let [form (first forms)\n                  threaded (if (seq? form)\n                             (with-meta (concat (list (first form) x)\n                                                (next form))\n                               (meta form))\n                             (list form x))]\n              (recur threaded (next forms))) x))]\n    (analyze ctx expanded)))\n\n(defn expand-as->\n  \"The ->> macro from clojure.core.\"\n  [ctx [_as expr name & forms]]\n  (let [[let-bindings & body] `([~name ~expr\n                                 ~@(interleave (repeat name) (butlast forms))]\n                                ~(if (empty? forms)\n                                   name\n                                   (last forms)))]\n    (expand-let* ctx let-bindings body)))\n\n(declare expand-declare)\n\n(defn expand-def\n  [ctx expr]\n  (let [[_def var-name ?docstring ?init] expr]\n    (expand-declare ctx [nil var-name])\n    (when-not (simple-symbol? var-name)\n      (throw-error-with-location \"Var name should be simple symbol.\" expr))\n    (let [arg-count (count expr)\n          docstring (when (and (= 4 arg-count)\n                               (string? ?docstring))\n                      ?docstring)\n          expected-arg-count (if docstring 4 3)]\n      (when-not (<= arg-count expected-arg-count)\n        (throw (new #?(:clj  IllegalArgumentException\n                       :cljs js/Error)\n                    \"Too many arguments to def\")))\n      (let [init (if docstring ?init ?docstring)\n            init (if (= 2 arg-count)\n                   :sci.impl/var.unbound\n                   (analyze ctx init))\n            m (meta var-name)\n            m (analyze ctx m)\n            m (assoc m :ns @vars/current-ns)\n            m (if docstring (assoc m :doc docstring) m)\n            var-name (with-meta var-name m)]\n        (mark-eval-call (list 'def var-name init))))))\n\n(defn expand-defn [ctx [op fn-name & body :as expr]]\n  (when-not (simple-symbol? fn-name)\n    (throw-error-with-location \"Var name should be simple symbol.\" expr))\n  (expand-declare ctx [nil fn-name])\n  (let [macro? (= \"defmacro\" (name op))\n        [pre-body body] (split-with (comp not sequential?) body)\n        _ (when (empty? body)\n            (throw-error-with-location \"Parameter declaration missing.\" expr))\n        docstring (when-let [ds (first pre-body)]\n                    (when (string? ds) ds))\n        meta-map (when-let [m (last pre-body)]\n                   (when (map? m) m))\n        meta-map (analyze ctx (merge (meta fn-name) (meta expr) meta-map))\n        fn-body (with-meta (cons 'fn body)\n                  (meta expr))\n        f (expand-fn ctx fn-body macro?)\n        arglists (seq (:sci.impl/arglists f))\n        meta-map (assoc meta-map\n                        :ns @vars/current-ns\n                        :arglists arglists)\n        fn-name (with-meta fn-name\n                  (cond-> meta-map\n                    docstring (assoc :doc docstring)\n                    macro? (assoc :macro true)))\n        f (assoc f\n                 :sci/macro macro?\n                 :sci.impl/fn-name fn-name)]\n    (mark-eval-call (list 'def fn-name f))))\n\n(defn expand-comment\n  \"The comment macro from clojure.core.\"\n  [_ctx & _body])\n\n(defn expand-loop\n  [ctx expr]\n  (let [bv (second expr)\n        arg-names (take-nth 2 bv)\n        init-vals (take-nth 2 (rest bv))\n        [bv syms] (if (every? symbol? arg-names)\n                    [bv arg-names]\n                    (let [syms (repeatedly (count arg-names) #(gensym))\n                          bv1 (map vector syms init-vals)\n                          bv2  (map vector arg-names syms)]\n                      [(into [] cat (interleave bv1 bv2)) syms]))\n        body (nnext expr)\n        expansion (list 'let bv\n                        (list* `(fn ~(vec arg-names) ~@body)\n                               syms))]\n    (analyze ctx expansion)))\n\n(defn expand-lazy-seq\n  [ctx expr]\n  (let [body (rest expr)]\n    (mark-eval-call\n     (list 'lazy-seq\n           (analyze ctx\n                    ;; expand-fn will take care of the analysis of the body\n                    (list 'fn [] (cons 'do body)))))))\n\n(defn expand-if\n  [ctx [_if & exprs :as expr]]\n  (case (count exprs)\n    (0 1) (throw-error-with-location \"Too few arguments to if\" expr)\n    (2 3) (mark-eval-call `(~'if ~@(analyze-children ctx exprs)))\n    (throw-error-with-location \"Too many arguments to if\" expr)))\n\n(defn expand-case\n  [ctx expr]\n  (let [v (analyze ctx (second expr))\n        clauses (nnext expr)\n        match-clauses (take-nth 2 clauses)\n        result-clauses (analyze-children ctx (take-nth 2 (rest clauses)))\n        default (when (odd? (count clauses))\n                  [:val (analyze ctx (last clauses))])\n        cases (interleave match-clauses result-clauses)\n        assoc-new (fn [m k v]\n                    (if-not (contains? m k)\n                      (assoc m k v)\n                      (throw-error-with-location (str \"Duplicate case test constant \" k)\n                                                 expr)))\n        case-map (loop [cases (seq cases)\n                        ret-map {}]\n                   (if cases\n                     (let [[k v & cases] cases]\n                       (if (list? k)\n                         (recur\n                          cases\n                          (reduce (fn [acc k]\n                                    (assoc-new acc k v))\n                                  ret-map\n                                  k))\n                         (recur\n                          cases\n                          (assoc-new ret-map k v))))\n                     ret-map))\n        ret (mark-eval-call (list 'case\n                                  {:case-map case-map\n                                   :case-val v\n                                   :case-default default}\n                                  default))]\n    (mark-eval-call ret)))\n\n(defn expand-try\n  [ctx [_try & body]]\n  (let [[body-exprs\n         catches\n         finally]\n        (loop [exprs #_[expr & exprs :as all-exprs] (seq body)\n               body-exprs []\n               catch-exprs []\n               finally-expr nil]\n          (if exprs\n            (let [expr (first exprs)\n                  exprs (next exprs)]\n              (cond (and (seq? expr) (= 'catch (first expr)))\n                    (recur exprs body-exprs (conj catch-exprs expr) finally-expr)\n                    (and (not exprs) (and (seq? expr) (= 'finally (first expr))))\n                    [body-exprs catch-exprs expr]\n                    :else\n                    ;; TODO: cannot add body expression when catch is not empty\n                    ;; TODO: can't have finally as non-last expression\n                    (recur exprs (conj body-exprs expr) catch-exprs finally-expr)))\n            [body-exprs catch-exprs finally-expr]))\n        body (analyze ctx (cons 'do body-exprs))\n        catches (mapv (fn [c]\n                        (let [[_ ex binding & body] c]\n                          (if-let [clazz (interop/resolve-class ctx ex)]\n                            {:class clazz\n                             :binding binding\n                             :body (analyze (assoc-in ctx [:bindings binding] nil)\n                                            (cons 'do body))}\n                            (throw-error-with-location (str \"Unable to resolve classname: \" ex) ex))))\n                      catches)\n        finally (when finally\n                  (analyze ctx (cons 'do (rest finally))))]\n    (with-meta\n      {:sci.impl/try\n       {:body body\n        :catches catches\n        :finally finally}}\n      {:sci.impl/op :try})))\n\n(defn expand-declare [ctx [_declare & names :as _expr]]\n  (swap! (:env ctx)\n         (fn [env]\n           (let [cnn (vars/current-ns-name)]\n             (update-in env [:namespaces cnn]\n                        (fn [current-ns]\n                          (reduce (fn [acc name]\n                                    (if (contains? acc name)\n                                      ;; declare does not override an existing\n                                      ;; var\n                                      acc\n                                      (assoc acc name\n                                             (doto (vars/->SciVar nil (symbol (str cnn)\n                                                                              (str name))\n                                                                  (assoc (meta name)\n                                                                         :name name\n                                                                         :ns @vars/current-ns\n                                                                         :file @vars/current-file))\n                                               (vars/unbind)))))\n                                  current-ns\n                                  names))))))\n  nil)\n\n;;;; Interop\n\n(defn expand-dot [ctx [_dot instance-expr method-expr & args :as _expr]]\n  (let [[method-expr & args] (if (seq? method-expr) method-expr\n                                 (cons method-expr args))\n        instance-expr (analyze ctx instance-expr)\n        instance-expr (utils/vary-meta*\n                       instance-expr\n                       (fn [m]\n                         (if-let [t (:tag m)]\n                           (let [clazz (or (interop/resolve-class ctx t)\n                                           (records/resolve-record-class ctx t)\n                                           (throw-error-with-location\n                                            (str \"Unable to resolve classname: \" t) t))]\n                             (assoc m :tag-class clazz))\n                           m)))\n        method-expr (name method-expr)\n        args (when args (analyze-children ctx args))\n        res #?(:clj (if (class? instance-expr)\n                      (if (nil? args)\n                        (if (str/starts-with? method-expr \"-\")\n                          (with-meta [instance-expr (subs method-expr 1)]\n                            {:sci.impl/op :static-access})\n                          ;; https://clojure.org/reference/java_interop\n                          ;; If the second operand is a symbol and no args are\n                          ;; supplied it is taken to be a field access - the\n                          ;; name of the field is the name of the symbol, and\n                          ;; the value of the expression is the value of the\n                          ;; field, unless there is a no argument public method\n                          ;; of the same name, in which case it resolves to a\n                          ;; call to the method.\n                          (if-let [_\n                                   (try (Reflector/getStaticField ^Class instance-expr ^String method-expr)\n                                        (catch IllegalArgumentException _ nil))]\n                            (with-meta [instance-expr method-expr]\n                              {:sci.impl/op :static-access})\n                            (mark-eval-call\n                             `(~(with-meta [instance-expr method-expr]\n                                  {:sci.impl/op :static-access}) ~@args))))\n                        (mark-eval-call\n                         `(~(with-meta [instance-expr method-expr]\n                              {:sci.impl/op :static-access}) ~@args)))\n                      (mark-eval-call `(~'. ~instance-expr ~method-expr ~args)))\n               :cljs (mark-eval-call `(~'. ~instance-expr ~method-expr ~args)))]\n    res))\n\n(defn expand-dot**\n  \"Expands (. x method)\"\n  [ctx expr]\n  (when (< (count expr) 3)\n    (throw (new #?(:clj IllegalArgumentException :cljs js/Error)\n                \"Malformed member expression, expecting (.member target ...)\")))\n  (expand-dot ctx expr))\n\n(defn expand-dot*\n  \"Expands (.foo x)\"\n  [ctx [method-name obj & args :as expr]]\n  (when (< (count expr) 2)\n    (throw (new #?(:clj IllegalArgumentException :cljs js/Error)\n                \"Malformed member expression, expecting (.member target ...)\")))\n  (expand-dot ctx (list '. obj (cons (symbol (subs (name method-name) 1)) args))))\n\n(defn expand-new [ctx [_new class-sym & args :as _expr]]\n  (if-let [#?(:clj {:keys [:class] :as _opts}\n              :cljs {:keys [:constructor] :as _opts}) (interop/resolve-class-opts ctx class-sym)]\n    (let [args (analyze-children ctx args)] ;; analyze args!\n      (mark-eval-call (list 'new #?(:clj class :cljs constructor) args)))\n    (if-let [record (records/resolve-record-class ctx class-sym)]\n      (let [args (analyze-children ctx args)]\n        (mark-eval-call (list* (:sci.impl.record/constructor (meta record)) args)))\n      (throw-error-with-location (str \"Unable to resolve classname: \" class-sym) class-sym))))\n\n(defn expand-constructor [ctx [constructor-sym & args]]\n  (let [;; TODO:\n        ;; here it strips the namespace, which is correct in the case of\n        ;; js/Error. but not in clj\n        constructor-name (name constructor-sym)\n        class-sym (with-meta (symbol (subs constructor-name 0\n                                           (dec (count constructor-name))))\n                    (meta constructor-sym))]\n    (expand-new ctx (with-meta (list* 'new class-sym args)\n                      (meta constructor-sym)))))\n\n;;;; End interop\n\n;;;; Namespaces\n\n(defn analyze-ns-form [ctx [_ns ns-name & exprs]]\n  (when-not (symbol? ns-name)\n    (throw (new #?(:clj IllegalArgumentException\n                   :cljs js/Error)\n                (str \"Namespace name must be symbol, got: \" (pr-str ns-name)))))\n  (let [[docstring exprs]\n        (let [fexpr (first exprs)]\n          (if (string? fexpr)\n            [fexpr (next exprs)]\n            [nil exprs]))\n        ;; skip attr-map\n        [attr-map exprs]\n        (let [m (first exprs)]\n          (if (map? m)\n            [m (next exprs)]\n            [nil exprs]))\n        attr-map (if docstring\n                   (assoc attr-map :doc docstring)\n                   attr-map)]\n    (set-namespace! ctx ns-name attr-map)\n    (loop [exprs exprs\n           ret []]\n      (if exprs\n        (let [[k & args] (first exprs)]\n          (case k\n            (:require :use)\n            (recur (next exprs)\n                   (conj ret\n                         (mark-eval-call\n                          (list* (symbol (name k)) args))))\n            :import (recur (next exprs) (conj ret (mark-eval-call (list* 'import args))))\n            :refer-clojure (recur (next exprs)\n                                  (conj ret\n                                        (mark-eval-call\n                                         (list* 'refer 'clojure.core args))))\n            :gen-class ;; ignore\n            (recur (next exprs) ret)))\n        (mark-eval-call (list* 'do ret))))))\n\n;;;; End namespaces\n\n\n;;;; Vars\n\n(defn analyze-var [ctx [_ var-name]]\n  (resolve-symbol (assoc ctx :sci.impl/prevent-deref true) var-name))\n\n(defn analyze-set! [ctx [_ obj v]]\n  (let [obj (analyze ctx obj)\n        v (analyze ctx v)\n        obj (types/getVal obj)]\n    (mark-eval-call (list 'set! obj v))))\n\n;;;; End vars\n\n;;;; Macros\n\n(defn macro? [f]\n  (when-let [m (meta f)]\n    (or (:sci/macro m)\n        (:macro m))))\n\n;;;; End macros\n\n(defn analyze-call [ctx expr]\n  (let [f (first expr)]\n    (if (symbol? f)\n      (let [;; in call position Clojure prioritizes special symbols over\n            ;; bindings\n            special-sym (get special-syms f)\n            _ (when special-sym (check-permission! ctx special-sym f))\n            f (or special-sym\n                  (resolve-symbol ctx f true))\n            f (if (and (vars/var? f)\n                       (or\n                        (vars/isMacro f)\n                        (let [m (meta f)]\n                          (and\n                           (:sci.impl/built-in m)\n                           (not (:dynamic m))))))\n                @f f)\n            f-meta (meta f)\n            eval? (and f-meta (:sci.impl/op f-meta))]\n        (cond (and f-meta (::static-access f-meta))\n              (expand-dot** ctx (list* '. (first f) (second f) (rest expr)))\n              (and (not eval?) ;; the symbol is not a binding\n                   (or\n                    special-sym\n                    (contains? macros f)))\n              (case f\n                ;; we treat every subexpression of a top-level do as a separate\n                ;; analysis/interpretation unit so we hand this over to the\n                ;; interpreter again, which will invoke analysis + evaluation on\n                ;; every sub expression\n                do (mark-eval-call (cons 'do\n                                         (analyze-children ctx (rest expr))))\n                let (expand-let ctx expr)\n                (fn fn*) (expand-fn ctx expr false)\n                def (expand-def ctx expr)\n                ;; NOTE: defn / defmacro aren't implemented as normal macros yet\n                (defn defmacro) (let [ret (expand-defn ctx expr)]\n                                  ret)\n                ;; TODO: implement as normal macro in namespaces.cljc\n                -> (expand-> ctx (rest expr))\n                ;; TODO: implement as normal macro in namespaces.cljc\n                as-> (expand-as-> ctx expr)\n                quote (do nil (second expr))\n                ;; TODO: implement as normal macro in namespaces.cljc\n                comment (expand-comment ctx expr)\n                loop (expand-loop ctx expr)\n                lazy-seq (expand-lazy-seq ctx expr)\n                for (let [res (expand-for ctx expr)]\n                      (if (:sci.impl/macroexpanding ctx)\n                        res\n                        (analyze ctx res)))\n                doseq (analyze ctx (expand-doseq ctx expr))\n                if (expand-if ctx expr)\n                case (expand-case ctx expr)\n                try (expand-try ctx expr)\n                declare (expand-declare ctx expr)\n                expand-dot* (expand-dot* ctx expr)\n                . (expand-dot** ctx expr)\n                expand-constructor (expand-constructor ctx expr)\n                new (expand-new ctx expr)\n                ns (analyze-ns-form ctx expr)\n                var (analyze-var ctx expr)\n                set! (analyze-set! ctx expr)\n                import (mark-eval-call expr) ;; don't analyze children\n                ;; macroexpand-1 (macroexpand-1 ctx expr)\n                ;; macroexpand (macroexpand ctx expr)\n                ;; else:\n                (mark-eval-call (cons f (analyze-children ctx (rest expr)))))\n              :else\n              (try\n                (if (macro? f)\n                  (let [needs-ctx? (kw-identical? :needs-ctx\n                                                  (:sci.impl/op (meta f)))\n                        v (if needs-ctx?\n                            (apply f expr\n                                   (:bindings ctx)\n                                   ctx\n                                   (rest expr))\n                            (apply f expr\n                                   (:bindings ctx) (rest expr)))\n                        expanded (if (:sci.impl/macroexpanding ctx)\n                                   v\n                                   (analyze ctx v))]\n                    expanded)\n                  (mark-eval-call (cons f (analyze-children ctx (rest expr)))))\n                (catch #?(:clj Exception :cljs js/Error) e\n                  (rethrow-with-location-of-node ctx e expr)))))\n      (let [ret (mark-eval-call (analyze-children ctx expr))]\n        ret))))\n\n(defn analyze\n  [ctx expr]\n  ;; (prn \"ana\" expr)\n  (let [ret (cond (constant? expr) expr ;; constants do not carry metadata\n                  (symbol? expr) (let [v (resolve-symbol ctx expr false)]\n                                   (cond (constant? v) v\n                                         ;; (fn? v) (utils/vary-meta* v dissoc :sci.impl/op)\n                                         (vars/var? v) (if (:const (meta v))\n                                                         @v (types/->EvalVar v))\n                                         :else (merge-meta v (meta expr))))\n                  :else\n                  (merge-meta\n                   (cond\n                     (map? expr)\n                     (-> (zipmap (analyze-children ctx (keys expr))\n                                 (analyze-children ctx (vals expr)))\n                         mark-eval)\n                     (or (vector? expr) (set? expr))\n                     (-> (into (empty expr) (analyze-children ctx expr))\n                         mark-eval)\n                     (and (seq? expr) (seq expr))\n                     (analyze-call ctx expr)\n                     :else expr)\n                   (select-keys (meta expr)\n                                [:line :column :tag])))]\n    ;; (prn \"ana\" expr '-> ret 'm-> (meta ret))\n    ret))\n\n;;;; Scratch\n\n(comment\n  )\n"]}