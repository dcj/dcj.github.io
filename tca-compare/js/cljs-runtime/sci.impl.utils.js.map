{"version":3,"sources":["sci/impl/utils.cljc"],"mappings":"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","names":["cljs.core.derive","sci.impl.utils/constant?","x","cljs.core/Keyword","sci.impl.utils/mark-resolve-sym","sym","cljs.core.vary_meta","m","cljs.core.assoc","sci.impl.utils/eval?","G__105668","cljs.core/meta","sci.impl.utils/kw-identical?","cljs.core/keyword-identical?","var_args","G__105673","sci.impl.utils/gensym*","js/Error","cljs.core.gensym","prefix","sci.impl.utils/mark-eval-call","expr","sci.impl.utils/mark-eval","G__105695","sci.impl.utils/throw-error-with-location","msg","iobj","sci.impl.utils.throw_error_with_location","data","map__105701","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","line","cljs.core.get","column","temp__5735__auto__","cljs.core/deref","v","sci.impl.vars/current-file","cljs.core.ex_info","cljs.core.merge","sci.impl.utils/*in-try*","sci.impl.utils/rethrow-with-location-of-node","ctx","e","node","cljs.core/not","ex-msg","and__4115__auto__","clojure.string/includes?","map__105722","new-exception","d","cljs.core/ex-data","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","sci.impl.utils/vary-meta*","seq105734","G__105735","cljs.core/first","cljs.core/next","G__105736","self__4723__auto__","obj","f","args","cljs.core/vary-meta","sci.impl.utils/merge-meta","temp__5733__auto__","cljs.core/with-meta","sci.impl.utils/strip-core-ns","G__105763","cljs.core/namespace","cljs.core.symbol","cljs.core/name","sci.impl.utils/allowed-loop","sci.impl.utils/allowed-recur","sci.impl.utils/walk*","inner","form","cljs.core/list?","cljs.core/list","cljs.core.map","cljs.core/map-entry?","cljs.core/MapEntry","G__105769","cljs.core/key","G__105770","cljs.core/val","cljs.core/seq?","cljs.core.doall","cljs.core/record?","cljs.core.reduce","r","cljs.core.conj","cljs.core/coll?","cljs.core.into","cljs.core/empty","sci.impl.utils/prewalk","cljs.core.partial","sci.impl.utils/namespace-object","env","ns-sym","create?","attr-map","env*","ns-map","cljs.core.get_in","or__4126__auto__","ns-obj","sci.impl.vars/->SciNamespace","cljs.core.swap_BANG_","cljs.core/assoc-in","sci.impl.utils/set-namespace!","sci.impl.types/setVal","sci.impl.vars/current-ns","sci.impl.utils/eval-form-state","cljs.core/volatile!","sci.impl.utils/eval-require-state","sci.impl.utils/eval-use-state","sci.impl.utils/eval-resolve-state","sci.impl.utils/eval-refer-state","sci.impl.utils/split-when","pred","coll","cljs.core/LazySeq","s","cljs.core/seq","fst","cljs.core/complement","run","cljs.core/cons","p1__105823#","cljs.core.take_while","G__105832","G__105833","cljs.core.drop","cljs.core/count"],"sourcesContent":["(ns sci.impl.utils\n  {:no-doc true}\n  (:require [clojure.string :as str]\n            [sci.impl.types :as t]\n            [sci.impl.vars :as vars]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(derive :sci.error/realized-beyond-max :sci/error)\n\n(defn constant? [x]\n  (or (number? x) (string? x) (keyword? x)))\n\n(defn mark-resolve-sym\n  [sym]\n  (vary-meta\n   sym\n   (fn [m]\n     (assoc m :sci.impl/op :resolve-sym))))\n\n(defn eval? [x]\n  (some-> x meta :sci.impl/op))\n\n(def kw-identical? #?(:clj identical? :cljs keyword-identical?))\n\n(defn gensym*\n  ([] (mark-resolve-sym (gensym)))\n  ([prefix] (mark-resolve-sym (gensym prefix))))\n\n(defn mark-eval-call\n  [expr]\n  (vary-meta\n   expr\n   (fn [m]\n     (assoc m :sci.impl/op :call))))\n\n(defn mark-eval\n  [expr]\n  (vary-meta\n   expr\n   (fn [m]\n     (assoc m :sci.impl/op :eval))))\n\n(defn throw-error-with-location\n  ([msg iobj] (throw-error-with-location msg iobj {}))\n  ([msg iobj data]\n   (let [{:keys [:line :column]} (meta iobj)\n         msg (str msg\n                  \" [at \"\n                  (when-let [v @vars/current-file]\n                    (str v \", \"))\n                  \"line \"\n                  line \", column \" column\"]\") ]\n     (throw (ex-info msg (merge {:type :sci/error\n                                 :line line\n                                 :column column} data))))))\n\n(def ^:dynamic *in-try* false)\n\n(defn rethrow-with-location-of-node [ctx ^Throwable e node]\n  (if-not *in-try*\n    (let [ex-msg (or #?(:clj (or (.getMessage e))\n                        :cljs (.-message e)))]\n      (if (and ex-msg (str/includes? ex-msg \"[at\"))\n        (throw e)\n        (let [{:keys [:line :column] :or {line (:line ctx)\n                                          column (:column ctx)}} (meta node)]\n          (if (and line column)\n            (let [m (str ex-msg\n                         (when ex-msg \" \")\n                         \"[at \"\n                         (when-let [v @vars/current-file]\n                           (str v \", \"))\n                         \"line \"\n                         line \", column \" column\"]\")\n                  new-exception\n                  (let [d (ex-data e)]\n                    (ex-info m (merge\n                                {:type :sci/error\n                                 :line line\n                                 :column column\n                                 :message m} d) e))]\n              (throw new-exception))\n            (throw e))))\n      (throw e))\n    (throw e)))\n\n(defn vary-meta*\n  \"Only adds metadata to obj if d is not nil and if obj already has meta\"\n  [obj f & args]\n  (if (and #?(:clj (instance? clojure.lang.IObj obj)\n              :cljs (implements? IWithMeta obj))\n           (meta obj))\n    (apply vary-meta obj f args)\n    obj))\n\n(defn merge-meta\n  \"Only adds metadata to obj if d is not nil and if meta on obj isn't already nil.\"\n  [obj d]\n  (if (and d #?(:clj (instance? clojure.lang.IObj obj)\n                :cljs (implements? IWithMeta obj)))\n    (if-let [m (meta obj)]\n      (with-meta obj (merge m d))\n      obj)\n    obj))\n\n(defn strip-core-ns [sym]\n  (case (namespace sym)\n    (\"clojure.core\" \"cljs.core\") (symbol (name sym))\n    sym))\n\n(def allowed-loop (with-meta (symbol \"loop\") {:line :allow}))\n(def allowed-recur (with-meta (symbol \"recur\") {:line :allow}))\n\n(defn walk*\n  [inner form]\n  (cond\n    (:sci.impl/op (meta form)) form\n    (list? form) (with-meta (apply list (map inner form))\n                   (meta form))\n    #?(:clj (instance? clojure.lang.IMapEntry form) :cljs (map-entry? form))\n    #?(:clj (clojure.lang.MapEntry/create (inner (key form)) (inner (val form)))\n       :cljs (MapEntry. (inner (key form)) (inner (val form)) nil))\n    (seq? form) (with-meta (doall (map inner form))\n                  (meta form))\n    #?(:clj (instance? clojure.lang.IRecord form)\n       :cljs (record? form))\n    (reduce (fn [r x] (conj r (inner x))) form form)\n    (coll? form) (into (empty form) (map inner form))\n    :else form))\n\n(defn prewalk\n  \"Prewalk with metadata preservation. Does not prewalk :sci.impl/op nodes.\"\n  [f form]\n  (walk* (partial prewalk f) (f form)))\n\n(defn namespace-object\n  \"Fetches namespaces from env if it exists. Else, if `create?`,\n  produces one regardless of the existince of the namespace in env and\n  adds it to env before returning it.\"\n  [env ns-sym create? attr-map]\n  (let [env* @env\n        ns-map (get-in env* [:namespaces ns-sym])]\n    (or (:obj ns-map)\n        (when (or ns-map create?)\n          (let [ns-obj (vars/->SciNamespace ns-sym attr-map)]\n            (swap! env assoc-in [:namespaces ns-sym :obj] ns-obj)\n            ns-obj)))))\n\n(defn set-namespace! [ctx ns-sym attr-map]\n  (let [env (:env ctx)\n        attr-map (merge (meta ns-sym) attr-map)\n        ns-obj (namespace-object env ns-sym true attr-map)]\n    (t/setVal vars/current-ns ns-obj)))\n\n(def eval-form-state (volatile! nil))\n(def eval-require-state (volatile! nil))\n(def eval-use-state (volatile! nil))\n(def eval-resolve-state (volatile! nil))\n(def eval-refer-state (volatile! nil))\n\n(defn split-when\n  \"Like partition-by but splits collection only when `pred` returns\n  a truthy value. E.g. `(split-when odd? [1 2 3 4 5]) => ((1 2) (3 4) (5))`\"\n  [pred coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [fst (first s)\n           f (complement pred)\n           run (cons fst (take-while #(f %) (next s)))]\n       (cons run (split-when pred (lazy-seq (drop (count run) s))))))))\n"]}