{
"version":3,
"file":"module$node_modules$vega_regression$build$vega_regression.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/vega-regression/build/vega-regression.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$vega_regression$build$vega_regression\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-statistics'), require('vega-dataflow'), require('vega-util')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-statistics', 'vega-dataflow', 'vega-util'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.vega = global.vega || {}, global.vega.transforms = {}), global.vega, global.vega, global.vega));\n}(this, (function (exports, vegaStatistics, vegaDataflow, vegaUtil) { 'use strict';\n\n  function partition(data, groupby) {\n    var groups = [],\n        get = function(f) { return f(t); },\n        map, i, n, t, k, g;\n\n    // partition data points into stack groups\n    if (groupby == null) {\n      groups.push(data);\n    } else {\n      for (map={}, i=0, n=data.length; i<n; ++i) {\n        t = data[i];\n        k = groupby.map(get);\n        g = map[k];\n        if (!g) {\n          map[k] = (g = []);\n          g.dims = k;\n          groups.push(g);\n        }\n        g.push(t);\n      }\n    }\n\n    return groups;\n  }\n\n  /**\n   * Compute locally-weighted regression fits for one or more data groups.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.x - An accessor for the predictor data field.\n   * @param {function(object): *} params.y - An accessor for the predicted data field.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n   * @param {number} [params.bandwidth=0.3] - The loess bandwidth.\n   */\n  function Loess(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Loess.Definition = {\n    'type': 'Loess',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'x', 'type': 'field', 'required': true },\n      { 'name': 'y', 'type': 'field', 'required': true },\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'bandwidth', 'type': 'number', 'default': 0.3 },\n      { 'name': 'as', 'type': 'string', 'array': true }\n    ]\n  };\n\n  vegaUtil.inherits(Loess, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n      if (!this.value || pulse.changed() || _.modified()) {\n        const source = pulse.materialize(pulse.SOURCE).source,\n              groups = partition(source, _.groupby),\n              names = (_.groupby || []).map(vegaUtil.accessorName),\n              m = names.length,\n              as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)],\n              values = [];\n\n        groups.forEach(g => {\n          vegaStatistics.regressionLoess(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {\n            const t = {};\n            for (let i=0; i<m; ++i) {\n              t[names[i]] = g.dims[i];\n            }\n            t[as[0]] = p[0];\n            t[as[1]] = p[1];\n            values.push(vegaDataflow.ingest(t));\n          });\n        });\n\n        if (this.value) out.rem = this.value;\n        this.value = out.add = out.source = values;\n      }\n\n      return out;\n    }\n  });\n\n  const Methods = {\n    linear: vegaStatistics.regressionLinear,\n    log:    vegaStatistics.regressionLog,\n    exp:    vegaStatistics.regressionExp,\n    pow:    vegaStatistics.regressionPow,\n    quad:   vegaStatistics.regressionQuad,\n    poly:   vegaStatistics.regressionPoly\n  };\n\n  const degreesOfFreedom = (method, order) =>\n    method === 'poly' ? order : method === 'quad' ? 2 : 1;\n\n  /**\n   * Compute regression fits for one or more data groups.\n   * @constructor\n   * @param {object} params - The parameters for this operator.\n   * @param {function(object): *} params.x - An accessor for the predictor data field.\n   * @param {function(object): *} params.y - An accessor for the predicted data field.\n   * @param {string} [params.method='linear'] - The regression method to apply.\n   * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.\n   * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.\n   * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.\n   */\n  function Regression(params) {\n    vegaDataflow.Transform.call(this, null, params);\n  }\n\n  Regression.Definition = {\n    'type': 'Regression',\n    'metadata': {'generates': true},\n    'params': [\n      { 'name': 'x', 'type': 'field', 'required': true },\n      { 'name': 'y', 'type': 'field', 'required': true },\n      { 'name': 'groupby', 'type': 'field', 'array': true },\n      { 'name': 'method', 'type': 'string', 'default': 'linear', 'values': Object.keys(Methods) },\n      { 'name': 'order', 'type': 'number', 'default': 3 },\n      { 'name': 'extent', 'type': 'number', 'array': true, 'length': 2 },\n      { 'name': 'params', 'type': 'boolean', 'default': false },\n      { 'name': 'as', 'type': 'string', 'array': true }\n    ]\n  };\n\n  vegaUtil.inherits(Regression, vegaDataflow.Transform, {\n    transform(_, pulse) {\n      const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);\n\n      if (!this.value || pulse.changed() || _.modified()) {\n        const source = pulse.materialize(pulse.SOURCE).source,\n              groups = partition(source, _.groupby),\n              names = (_.groupby || []).map(vegaUtil.accessorName),\n              method = _.method || 'linear',\n              order = _.order || 3,\n              dof = degreesOfFreedom(method, order),\n              as = _.as || [vegaUtil.accessorName(_.x), vegaUtil.accessorName(_.y)],\n              fit = Methods[method],\n              values = [];\n\n        let domain = _.extent;\n\n        if (!vegaUtil.hasOwnProperty(Methods, method)) {\n          vegaUtil.error('Invalid regression method: ' + method);\n        }\n\n        if (domain != null) {\n          if (method === 'log' && domain[0] <= 0) {\n            pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');\n            domain = null;\n          }\n        }\n\n        groups.forEach(g => {\n          const n = g.length;\n          if (n <= dof) {\n            pulse.dataflow.warn('Skipping regression with more parameters than data points.');\n            return;\n          }\n\n          const model = fit(g, _.x, _.y, order);\n\n          if (_.params) {\n            // if parameter vectors requested return those\n            values.push(vegaDataflow.ingest({\n              keys: g.dims,\n              coef: model.coef,\n              rSquared: model.rSquared\n            }));\n            return;\n          }\n\n          const dom = domain || vegaUtil.extent(g, _.x),\n                add = p => {\n                  const t = {};\n                  for (let i=0; i<names.length; ++i) {\n                    t[names[i]] = g.dims[i];\n                  }\n                  t[as[0]] = p[0];\n                  t[as[1]] = p[1];\n                  values.push(vegaDataflow.ingest(t));\n                };\n\n          if (method === 'linear') {\n            // for linear regression we only need the end points\n            dom.forEach(x => add([x, model.predict(x)]));\n          } else {\n            // otherwise return trend line sample points\n            vegaStatistics.sampleCurve(model.predict, dom, 25, 200).forEach(add);\n          }\n        });\n\n        if (this.value) out.rem = this.value;\n        this.value = out.add = out.source = values;\n      }\n\n      return out;\n    }\n  });\n\n  exports.loess = Loess;\n  exports.regression = Regression;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};"],
"names":["shadow$provide","global","require","module","exports","factory","define","amd","globalThis","self","vega","transforms","vegaStatistics","vegaDataflow","vegaUtil","partition","data","groupby","groups","get","f","t","n","push","map","i","length","k","g","dims","Loess","params","Transform","call","Regression","Definition","inherits","transform","_","pulse","out","fork","NO_SOURCE","NO_FIELDS","value","changed","modified","source","materialize","SOURCE","names","accessorName","m","as","x","y","values","forEach","regressionLoess","bandwidth","p","ingest","rem","add","Methods","linear","regressionLinear","log","regressionLog","exp","regressionExp","pow","regressionPow","quad","regressionQuad","poly","regressionPoly","Object","keys","method","order","dof","fit","domain","extent","hasOwnProperty","error","dataflow","warn","model","coef","rSquared","dom","predict","sampleCurve","loess","regression","defineProperty"]
}
