{"version":3,"sources":["sci/impl/records.cljc"],"mappings":";AAOA,AAAA,AAAA,AAAAA,AAAMM;AAAN,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAME,AAAWU,AAAEA,AAAEC,AAAIC,AAAYC,AAASC;AAA9C,AACE,AAAMQ,AAAe,AAACC,AAAO,AAAA,AAAUX;AACjCY,AAAK,AAACC,AAAKC,AAAQb;AACnBC,AAAe,AAACa,AAAiBC,AAAQd;AACzCA,AACA,AAACe,AAAO,AAAAC;AAAA,AAAA,AAAAC,AAAAD;AAAAE,AAAA,AAAAhB,AAAAe;AAAAE,AAAA,AAAA9B,AAAA6B;AAAAA,AAAA,AAAA5B,AAAA4B;AAAAC,AAAMC;AAANF,AAAsBG;AAAtB,AACE,AAACC,AAAI,AAAKC;AAAL,AACE,AAAME,AAAa,AAAAC,AAAA,AAAAC,AAAEC;AAAF,AAAA,AAAAF,AAAAA,AAAAA,AAA2B7B,AAAAA,AAAIuB,AAAAA;;AAC5CS,AAAY,AAAA,AAAA,AAAIJ,AAAaE;AAC7BG,AAAI,AAAK,AAACC,AAAaF;AAF7B,AAAAL,AAGMQ;AAHN,AAGoB,AAAAR,AAACf,AAAOqB;;AACtBG,AAAK,AAACC,AAAOX;AACbY,AAAK,AAAC9C,AAAM4C;AACZG,AAAS,AAAC/B,AAAI,AAACU,AAAO,AAAKsB;AAAL,AAAA,AACGA,AAAM,AAAAjC,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAM,AAACkC,AAAQD,AAAOF;AAC/BpC;AAR5B,AAAA,AAAAE,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AASe,AAAC4B,AAAa,AAAK,AAAC3C,AAAMkC,AAAUzB,AAAa,AAACoC,AAAOX,AAC7Da,AACF,AAACG,AAAMhB;AAClBF;AACPrB;AAnBd,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAJ,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAH,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAE,AAAAC,AAAA,AAAAN,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAsBYI,AACeE,AAGQZ,AACxBA,AAAyBA,AAEoBU,AACjDR;;;AA/BT,AAAA,AAAA,AAAMd;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA,AAAAC,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAAI,AAAA,AAAAF,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAAK,AAAA,AAAAH,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAAM,AAAA,AAAAJ,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAAO,AAAA,AAAAL,AAAAF;AAAAA,AAAA,AAAAG,AAAAH;AAAA,AAAA,AAAAQ,AAAA;AAAA,AAAA,AAAAA,AAAAP,AAAAG,AAAAC,AAAAC,AAAAC,AAAAP;;;AAAA,AAiCA,AAAA,AAAMqD,AAAaC;AAAnB,AACE,AAAAC,AACC,AAAA,AAAM,AAACC,AAAKF,AACV,AAAAG,AAAQH;AAARG,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAAA,AAAUC;AAAV,AAAA,AAAA,AAAAD,AAAA;AAAA;;AAAA,AAAA,AAAAA;;AADF;AADD,AAAA,AAAAF;AAAAA;;AAGC,AAACI,AAAqBL;;;AAEzB,AAAA,AAAA,AAAA7D,AAAMoE;AAAN,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAMD,AACFnD,AAAIqD;AADR,AAEG,AAAMC,AAAQ,AAAKD;AACbE,AAAS,AAAA,AAACC,AAAkBF;AAC5BG,AAAW,AAAIF,AACF,AAACG,AAAKJ,AAAQ,AAAA,AAAKC,AAAU,AAAOD,AACpCA;AACbK,AAAU,AAAIJ,AACF,AAAC3C,AAAO,AAAA,AAAC8C,AAAKJ,AAAUC,AACxB,AAACK;AAPnB,AAQE,AAACC,AAAqB7D,AAAI2D,AAAU,AAAC/C,AAAO6C;;;AAVjD,AAAA,AAAA,AAAMN,AAWFnD,AAAI8D,AAAQC;AAXhB,AAYG,AAAMJ,AAAUG;AAAhB,AACE,AAAAE,AAAmB,AAAA,AAAAlC,AAAA,AAAA,AAACoC,AAAQ,AAAA,AAAMlE,AAAkB2D,AAAUI;AAA9D,AAAA,AAAAC;AAAA,AAAA,AAAAA,AAAWC;AAAX,AACE,AAAI,AAACE,AAAUF;AAAf,AAAAnC,AACGmC;;AACDA;;;AAHJ;;;;AAbL,AAAA,AAAA,AAAMd;;AAAN","names":["var_args","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","sci.impl.records/defrecord","seq105843","G__105844","cljs.core/first","cljs.core/next","G__105845","G__105846","G__105847","G__105848","self__4723__auto__","_","ctx","record-name","fields","protocol-impls","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/vec","cljs.core.apply","cljs.core/array-map","factory-fn-sym","cljs.core.symbol","keys","cljs.core.mapv","cljs.core/keyword","sci.impl.utils/split-when","cljs.core/symbol?","cljs.core.mapcat","p__105890","vec__105897","seq__105898","first__105899","protocol-name","impls","cljs.core.map","impl","p1__105840#","protocol-var","fexpr__105900","cljs.core/deref","sci.impl.utils/eval-resolve-state","protocol-ns","pns","sci.impl.vars/getName","fq-meth-name","args","cljs.core/second","this","bindings","field","cljs.core.keyword","cljs.core/nnext","sci.impl.records/sci-record?","x","or__4126__auto__","cljs.core/map?","G__105943","cljs.core/meta","cljs.core/record?","G__105946","sci.impl.records/resolve-record-class","js/Error","sym","sym-str","last-dot","clojure.string.last_index_of","class-name","cljs.core.subs","namespace","sci.impl.vars/current-ns-name","sci.impl.records.resolve_record_class","package","class","temp__5735__auto__","sci-var","cljs.core.get_in","sci.impl.vars/var?"],"sourcesContent":["(ns sci.impl.records\n  {:no-doc true}\n  (:refer-clojure :exclude [defrecord record?])\n  (:require [clojure.string :as str]\n            [sci.impl.utils :as utils]\n            [sci.impl.vars :as vars]))\n\n(defn defrecord [_ _ ctx record-name fields & protocol-impls]\n  (let [factory-fn-sym (symbol (str \"->\" record-name))\n        keys (mapv keyword fields)\n        protocol-impls (utils/split-when symbol? protocol-impls)\n        protocol-impls\n        (mapcat (fn [[protocol-name & impls]]\n                  (map (fn [impl]\n                         (let [protocol-var (@utils/eval-resolve-state ctx protocol-name)\n                               protocol-ns (-> protocol-var deref :ns)\n                               pns (str (vars/getName protocol-ns))\n                               fq-meth-name #(symbol pns %)\n                               args (second impl)\n                               this (first args)\n                               bindings (vec (mapcat (fn [field]\n                                                       [field (list (keyword field) this)])\n                                                     fields))]\n                           `(defmethod ~(fq-meth-name (str (first impl))) '~record-name ~(second impl)\n                              (let ~bindings\n                                ~@(nnext impl)))))\n                       impls))\n                protocol-impls)]\n    `(do\n       ;; (prn '~record-name)\n       (defn ~factory-fn-sym [& args#]\n         (vary-meta (zipmap ~keys args#)\n                    assoc\n                    :sci.impl/record true\n                    :sci.impl/type '~record-name))\n       (def ~record-name (with-meta '~record-name\n                           {:sci.impl/record true\n                            :sci.impl.record/constructor ~factory-fn-sym}))\n       ~@protocol-impls)))\n\n(defn sci-record? [x]\n  (or\n   (when (map? x)\n     (some-> x meta :sci.impl/record))\n   (clojure.core/record? x)))\n\n(defn resolve-record-class\n  ([ctx sym]\n   (let [sym-str (str sym)\n         last-dot (str/last-index-of sym-str \".\")\n         class-name (if last-dot\n                      (subs sym-str (inc last-dot) (count sym-str))\n                      sym-str)\n         namespace (if last-dot\n                     (symbol (subs sym-str 0 last-dot))\n                     (vars/current-ns-name))]\n     (resolve-record-class ctx namespace (symbol class-name))))\n  ([ctx package class]\n   (let [namespace package]\n     (when-let [sci-var (get-in @(:env ctx) [:namespaces namespace class])]\n       (if (vars/var? sci-var)\n         @sci-var\n         sci-var)))))\n"]}