{
"version":3,
"file":"module$node_modules$vega_runtime$build$vega_runtime.js",
"lineCount":23,
"mappings":"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",
"sources":["node_modules/vega-runtime/build/vega-runtime.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$vega_runtime$build$vega_runtime\"] = function(global,require,module,exports) {\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vega-util'), require('vega-dataflow')) :\n  typeof define === 'function' && define.amd ? define(['exports', 'vega-util', 'vega-dataflow'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.vega = {}, global.vega, global.vega));\n}(this, (function (exports, vegaUtil, vegaDataflow) { 'use strict';\n\n  /**\n   * Parse a serialized dataflow specification.\n   */\n  function parse(spec) {\n    const ctx = this,\n          operators = spec.operators || [];\n\n    // parse background\n    if (spec.background) {\n      ctx.background = spec.background;\n    }\n\n    // parse event configuration\n    if (spec.eventConfig) {\n      ctx.eventConfig = spec.eventConfig;\n    }\n\n    // parse locale configuration\n    if (spec.locale) {\n      ctx.locale = spec.locale;\n    }\n\n    // parse operators\n    operators.forEach(entry => ctx.parseOperator(entry));\n\n    // parse operator parameters\n    operators.forEach(entry => ctx.parseOperatorParameters(entry));\n\n    // parse streams\n    (spec.streams || []).forEach(entry => ctx.parseStream(entry));\n\n    // parse updates\n    (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));\n\n    return ctx.resolve();\n  }\n\n  const Skip = vegaUtil.toSet(['rule']),\n        Swap = vegaUtil.toSet(['group', 'image', 'rect']);\n\n  function adjustSpatial(encode, marktype) {\n    let code = '';\n\n    if (Skip[marktype]) return code;\n\n    if (encode.x2) {\n      if (encode.x) {\n        if (Swap[marktype]) {\n          code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';\n        }\n        code += 'o.width=o.x2-o.x;';\n      } else {\n        code += 'o.x=o.x2-(o.width||0);';\n      }\n    }\n\n    if (encode.xc) {\n      code += 'o.x=o.xc-(o.width||0)/2;';\n    }\n\n    if (encode.y2) {\n      if (encode.y) {\n        if (Swap[marktype]) {\n          code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';\n        }\n        code += 'o.height=o.y2-o.y;';\n      } else {\n        code += 'o.y=o.y2-(o.height||0);';\n      }\n    }\n\n    if (encode.yc) {\n      code += 'o.y=o.yc-(o.height||0)/2;';\n    }\n\n    return code;\n  }\n\n  function canonicalType(type) {\n    return (type + '').toLowerCase();\n  }\n\n  function isOperator(type) {\n     return canonicalType(type) === 'operator';\n  }\n\n  function isCollect(type) {\n    return canonicalType(type) === 'collect';\n  }\n\n  function expression(ctx, args, code) {\n    // wrap code in return statement if expression does not terminate\n    if (code[code.length-1] !== ';') {\n      code = 'return(' + code + ');';\n    }\n    var fn = Function.apply(null, args.concat(code));\n    return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;\n  }\n\n  // generate code for comparing a single field\n  function _compare(u, v, lt, gt) {\n    return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}\n  : (u > v || v == null) && u != null ? ${gt}\n  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}\n  : v !== v && u === u ? ${gt} : `;\n  }\n\n  var expressionCodegen = {\n    /**\n     * Parse an expression used to update an operator value.\n     */\n    operator: (ctx, expr) => expression(ctx, ['_'], expr.code),\n\n    /**\n     * Parse an expression provided as an operator parameter value.\n     */\n    parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),\n\n    /**\n     * Parse an expression applied to an event stream.\n     */\n    event: (ctx, expr) => expression(ctx, ['event'], expr.code),\n\n    /**\n     * Parse an expression used to handle an event-driven operator update.\n     */\n    handler: (ctx, expr) => {\n      const code = `var datum=event.item&&event.item.datum;return ${expr.code};`;\n      return expression(ctx, ['_', 'event'], code);\n    },\n\n    /**\n     * Parse an expression that performs visual encoding.\n     */\n    encode: (ctx, encode) => {\n      const {marktype, channels} = encode;\n\n      let code = 'var o=item,datum=o.datum,m=0,$;';\n      for (const name in channels) {\n        const o ='o[' + vegaUtil.stringValue(name) + ']';\n        code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;\n      }\n      code += adjustSpatial(channels, marktype);\n      code += 'return m;';\n\n      return expression(ctx, ['item', '_'], code);\n    },\n\n    /**\n     * Optimized code generators for access and comparison.\n     */\n    codegen: {\n      get(path) {\n        const ref = `[${path.map(vegaUtil.stringValue).join('][')}]`;\n        const get = Function('_', `return _${ref};`);\n        get.path = ref;\n        return get;\n      },\n      comparator(fields, orders) {\n        let t;\n        const map = (f, i) => {\n          const o = orders[i];\n          let u, v;\n          if (f.path) {\n            u = `a${f.path}`;\n            v = `b${f.path}`;\n          } else {\n            (t = t || {})['f'+i] = f;\n            u = `this.f${i}(a)`;\n            v = `this.f${i}(b)`;\n          }\n          return _compare(u, v, -o, o);\n        };\n\n        const fn = Function('a', 'b', 'var u, v; return '\n          + fields.map(map).join('') + '0;');\n        return t ? fn.bind(t) : fn;\n      }\n    }\n  };\n\n  /**\n   * Parse a dataflow operator.\n   */\n  function parseOperator(spec) {\n    const ctx = this;\n    if (isOperator(spec.type) || !spec.type) {\n      ctx.operator(\n        spec,\n        spec.update ? ctx.operatorExpression(spec.update) : null\n      );\n    } else {\n      ctx.transform(spec, spec.type);\n    }\n  }\n\n  /**\n   * Parse and assign operator parameters.\n   */\n  function parseOperatorParameters(spec) {\n    const ctx = this;\n    if (spec.params) {\n      const op = ctx.get(spec.id);\n      if (!op) vegaUtil.error('Invalid operator id: ' + spec.id);\n      ctx.dataflow.connect(op, op.parameters(\n        ctx.parseParameters(spec.params),\n        spec.react,\n        spec.initonly\n      ));\n    }\n  }\n\n  /**\n   * Parse a set of operator parameters.\n   */\n  function parseParameters(spec, params) {\n    params = params || {};\n    const ctx = this;\n\n    for (const key in spec) {\n      const value = spec[key];\n      params[key] = vegaUtil.isArray(value)\n        ? value.map(v => parseParameter(v, ctx, params))\n        : parseParameter(value, ctx, params);\n    }\n\n    return params;\n  }\n\n  /**\n   * Parse a single parameter.\n   */\n  function parseParameter(spec, ctx, params) {\n    if (!spec || !vegaUtil.isObject(spec)) return spec;\n\n    for (let i=0, n=PARSERS.length, p; i<n; ++i) {\n      p = PARSERS[i];\n      if (vegaUtil.hasOwnProperty(spec, p.key)) {\n        return p.parse(spec, ctx, params);\n      }\n    }\n\n    return spec;\n  }\n\n  /** Reference parsers. */\n  var PARSERS = [\n    {key: '$ref',      parse: getOperator},\n    {key: '$key',      parse: getKey},\n    {key: '$expr',     parse: getExpression},\n    {key: '$field',    parse: getField},\n    {key: '$encode',   parse: getEncode},\n    {key: '$compare',  parse: getCompare},\n    {key: '$context',  parse: getContext},\n    {key: '$subflow',  parse: getSubflow},\n    {key: '$tupleid',  parse: getTupleId}\n  ];\n\n  /**\n   * Resolve an operator reference.\n   */\n  function getOperator(_, ctx) {\n    return ctx.get(_.$ref) || vegaUtil.error('Operator not defined: ' + _.$ref);\n  }\n\n  /**\n   * Resolve an expression reference.\n   */\n  function getExpression(_, ctx, params) {\n    if (_.$params) { // parse expression parameters\n      ctx.parseParameters(_.$params, params);\n    }\n    const k = 'e:' + _.$expr.code + '_' + _.$name;\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.accessor(\n      ctx.parameterExpression(_.$expr),\n      _.$fields,\n      _.$name\n    ));\n  }\n\n  /**\n   * Resolve a key accessor reference.\n   */\n  function getKey(_, ctx) {\n    const k = 'k:' + _.$key + '_' + (!!_.$flat);\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.key(_.$key, _.$flat, ctx.expr.codegen));\n  }\n\n  /**\n   * Resolve a field accessor reference.\n   */\n  function getField(_, ctx) {\n    if (!_.$field) return null;\n    const k = 'f:' + _.$field + '_' + _.$name;\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.field(_.$field, _.$name, ctx.expr.codegen));\n  }\n\n  /**\n   * Resolve a comparator function reference.\n   */\n  function getCompare(_, ctx) {\n    // As of Vega 5.5.3, $tupleid sort is no longer used.\n    // Keep here for now for backwards compatibility.\n    const k = 'c:' + _.$compare + '_' + _.$order,\n          c = vegaUtil.array(_.$compare).map(_ => (_ && _.$tupleid) ? vegaDataflow.tupleid : _);\n    return ctx.fn[k] || (ctx.fn[k] = vegaUtil.compare(c, _.$order, ctx.expr.codegen));\n  }\n\n  /**\n   * Resolve an encode operator reference.\n   */\n  function getEncode(_, ctx) {\n    const spec = _.$encode,\n          encode = {};\n\n    for (const name in spec) {\n      const enc = spec[name];\n      encode[name] = vegaUtil.accessor(ctx.encodeExpression(enc.$expr), enc.$fields);\n      encode[name].output = enc.$output;\n    }\n    return encode;\n  }\n\n  /**\n   * Resolve a context reference.\n   */\n  function getContext(_, ctx) {\n    return ctx;\n  }\n\n  /**\n   * Resolve a recursive subflow specification.\n   */\n  function getSubflow(_, ctx) {\n    const spec = _.$subflow;\n    return function(dataflow, key, parent) {\n      const subctx = ctx.fork().parse(spec),\n            op = subctx.get(spec.operators[0].id),\n            p = subctx.signals.parent;\n      if (p) p.set(parent);\n      op.detachSubflow = () => ctx.detach(subctx);\n      return op;\n    };\n  }\n\n  /**\n   * Resolve a tuple id reference.\n   */\n  function getTupleId() {\n    return vegaDataflow.tupleid;\n  }\n\n  /**\n   * Parse an event stream specification.\n   */\n  function parseStream(spec) {\n    var ctx = this,\n        filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,\n        stream = spec.stream != null ? ctx.get(spec.stream) : undefined,\n        args;\n\n    if (spec.source) {\n      stream = ctx.events(spec.source, spec.type, filter);\n    }\n    else if (spec.merge) {\n      args = spec.merge.map(_ => ctx.get(_));\n      stream = args[0].merge.apply(args[0], args.slice(1));\n    }\n\n    if (spec.between) {\n      args = spec.between.map(_ => ctx.get(_));\n      stream = stream.between(args[0], args[1]);\n    }\n\n    if (spec.filter) {\n      stream = stream.filter(filter);\n    }\n\n    if (spec.throttle != null) {\n      stream = stream.throttle(+spec.throttle);\n    }\n\n    if (spec.debounce != null) {\n      stream = stream.debounce(+spec.debounce);\n    }\n\n    if (stream == null) {\n      vegaUtil.error('Invalid stream definition: ' + JSON.stringify(spec));\n    }\n\n    if (spec.consume) stream.consume(true);\n\n    ctx.stream(spec, stream);\n  }\n\n  /**\n   * Parse an event-driven operator update.\n   */\n  function parseUpdate(spec) {\n    var ctx = this,\n        srcid = vegaUtil.isObject(srcid = spec.source) ? srcid.$ref : srcid,\n        source = ctx.get(srcid),\n        target = null,\n        update = spec.update,\n        params = undefined;\n\n    if (!source) vegaUtil.error('Source not defined: ' + spec.source);\n\n    target = spec.target && spec.target.$expr\n      ? ctx.eventExpression(spec.target.$expr)\n      : ctx.get(spec.target);\n\n    if (update && update.$expr) {\n      if (update.$params) {\n        params = ctx.parseParameters(update.$params);\n      }\n      update = ctx.handlerExpression(update.$expr);\n    }\n\n    ctx.update(spec, source, target, update, params);\n  }\n\n  var SKIP = {skip: true};\n\n  function getState(options) {\n    var ctx = this,\n        state = {};\n\n    if (options.signals) {\n      var signals = (state.signals = {});\n      Object.keys(ctx.signals).forEach(key => {\n        var op = ctx.signals[key];\n        if (options.signals(key, op)) {\n          signals[key] = op.value;\n        }\n      });\n    }\n\n    if (options.data) {\n      var data = (state.data = {});\n      Object.keys(ctx.data).forEach(key => {\n        var dataset = ctx.data[key];\n        if (options.data(key, dataset)) {\n          data[key] = dataset.input.value;\n        }\n      });\n    }\n\n    if (ctx.subcontext && options.recurse !== false) {\n      state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));\n    }\n\n    return state;\n  }\n\n  function setState(state) {\n    var ctx = this,\n        df = ctx.dataflow,\n        data = state.data,\n        signals = state.signals;\n\n    Object.keys(signals || {}).forEach(key => {\n      df.update(ctx.signals[key], signals[key], SKIP);\n    });\n\n    Object.keys(data || {}).forEach(key => {\n      df.pulse(\n        ctx.data[key].input,\n        df.changeset().remove(vegaUtil.truthy).insert(data[key])\n      );\n    });\n\n    (state.subcontext  || []).forEach((substate, i) => {\n      var subctx = ctx.subcontext[i];\n      if (subctx) subctx.setState(substate);\n    });\n  }\n\n  /**\n   * Context objects store the current parse state.\n   * Enables lookup of parsed operators, event streams, accessors, etc.\n   * Provides a 'fork' method for creating child contexts for subflows.\n   */\n  function context(df, transforms, functions, expr) {\n    return new Context(df, transforms, functions, expr);\n  }\n\n  function Context(df, transforms, functions, expr) {\n    this.dataflow = df;\n    this.transforms = transforms;\n    this.events = df.events.bind(df);\n    this.expr = expr || expressionCodegen,\n    this.signals = {};\n    this.scales = {};\n    this.nodes = {};\n    this.data = {};\n    this.fn = {};\n    if (functions) {\n      this.functions = Object.create(functions);\n      this.functions.context = this;\n    }\n  }\n\n  function Subcontext(ctx) {\n    this.dataflow = ctx.dataflow;\n    this.transforms = ctx.transforms;\n    this.events = ctx.events;\n    this.expr = ctx.expr;\n    this.signals = Object.create(ctx.signals);\n    this.scales = Object.create(ctx.scales);\n    this.nodes = Object.create(ctx.nodes);\n    this.data = Object.create(ctx.data);\n    this.fn = Object.create(ctx.fn);\n    if (ctx.functions) {\n      this.functions = Object.create(ctx.functions);\n      this.functions.context = this;\n    }\n  }\n\n  Context.prototype = Subcontext.prototype = {\n    fork() {\n      const ctx = new Subcontext(this);\n      (this.subcontext || (this.subcontext = [])).push(ctx);\n      return ctx;\n    },\n    detach(ctx) {\n      this.subcontext = this.subcontext.filter(c => c !== ctx);\n\n      // disconnect all nodes in the subcontext\n      // wipe out targets first for better efficiency\n      const keys = Object.keys(ctx.nodes);\n      for (const key of keys) ctx.nodes[key]._targets = null;\n      for (const key of keys) ctx.nodes[key].detach();\n      ctx.nodes = null;\n    },\n    get(id) {\n      return this.nodes[id];\n    },\n    set(id, node) {\n      return this.nodes[id] = node;\n    },\n    add(spec, op) {\n      const ctx = this,\n            df = ctx.dataflow,\n            data = spec.value;\n\n      ctx.set(spec.id, op);\n\n      if (isCollect(spec.type) && data) {\n        if (data.$ingest) {\n          df.ingest(op, data.$ingest, data.$format);\n        } else if (data.$request) {\n          df.preload(op, data.$request, data.$format);\n        } else {\n          df.pulse(op, df.changeset().insert(data));\n        }\n      }\n\n      if (spec.root) {\n        ctx.root = op;\n      }\n\n      if (spec.parent) {\n        var p = ctx.get(spec.parent.$ref);\n        if (p) {\n          df.connect(p, [op]);\n          op.targets().add(p);\n        } else {\n          (ctx.unresolved = ctx.unresolved || []).push(() => {\n            p = ctx.get(spec.parent.$ref);\n            df.connect(p, [op]);\n            op.targets().add(p);\n          });\n        }\n      }\n\n      if (spec.signal) {\n        ctx.signals[spec.signal] = op;\n      }\n\n      if (spec.scale) {\n        ctx.scales[spec.scale] = op;\n      }\n\n      if (spec.data) {\n        for (const name in spec.data) {\n          const data = ctx.data[name] || (ctx.data[name] = {});\n          spec.data[name].forEach(role => data[role] = op);\n        }\n      }\n    },\n    resolve() {\n      (this.unresolved || []).forEach(fn => fn());\n      delete this.unresolved;\n      return this;\n    },\n    operator(spec, update) {\n      this.add(spec, this.dataflow.add(spec.value, update));\n    },\n    transform(spec, type) {\n      this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));\n    },\n    stream(spec, stream) {\n      this.set(spec.id, stream);\n    },\n    update(spec, stream, target, update, params) {\n      this.dataflow.on(stream, target, update, params, spec.options);\n    },\n\n    // expression parsing\n    operatorExpression(expr) {\n      return this.expr.operator(this, expr);\n    },\n    parameterExpression(expr) {\n      return this.expr.parameter(this, expr);\n    },\n    eventExpression(expr) {\n      return this.expr.event(this, expr);\n    },\n    handlerExpression(expr) {\n      return this.expr.handler(this, expr);\n    },\n    encodeExpression(encode) {\n      return this.expr.encode(this, encode);\n    },\n\n    // parse methods\n    parse,\n    parseOperator,\n    parseOperatorParameters,\n    parseParameters,\n    parseStream,\n    parseUpdate,\n\n    // state methods\n    getState,\n    setState\n  };\n\n  exports.context = context;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n};"],
"names":["shadow$provide","global","require","module","exports","factory","define","amd","globalThis","self","vega","vegaUtil","vegaDataflow","expression","ctx","args","code","length","fn","Function","apply","concat","functions","bind","parseParameter","spec","params","isObject","i","n","PARSERS","p","hasOwnProperty","key","parse","Context","df","transforms","expr","dataflow","events","expressionCodegen","signals","scales","nodes","data","Object","create","context","Subcontext","Skip","toSet","Swap","operator","parameter","event","handler","encode","marktype","channels","name","o","stringValue","x2","x","xc","y2","y","yc","codegen","get","path","ref","map","join","comparator","fields","orders","t","f","u","v","lt","getOperator","_","$ref","error","getKey","k","$key","$flat","getExpression","$params","parseParameters","$expr","$name","accessor","parameterExpression","$fields","getField","$field","field","getEncode","$encode","enc","encodeExpression","output","$output","getCompare","$compare","$order","c","array","$tupleid","tupleid","compare","getContext","getSubflow","$subflow","parent","subctx","fork","op","operators","id","set","detachSubflow","op.detachSubflow","detach","getTupleId","SKIP","skip","prototype","push","subcontext","filter","keys","_targets","node","add","value","toLowerCase","type","$ingest","ingest","$format","$request","preload","pulse","changeset","insert","root","connect","targets","unresolved","signal","scale","forEach","role","resolve","update","transform","stream","target","on","options","operatorExpression","eventExpression","handlerExpression","background","eventConfig","locale","entry","parseOperator","parseOperatorParameters","streams","parseStream","updates","parseUpdate","parameters","react","initonly","isArray","undefined","source","merge","slice","between","throttle","debounce","JSON","stringify","consume","srcid","getState","state","dataset","input","recurse","setState","remove","truthy","substate","defineProperty"]
}
